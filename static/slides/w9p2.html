<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Review</title>
    <meta charset="utf-8" />
    <meta name="author" content="Daniel Anderson" />
    <script src="libs/header-attrs-2.7/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <script src="libs/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <link href="libs/countdown-0.3.5/countdown.css" rel="stylesheet" />
    <script src="libs/countdown-0.3.5/countdown.js"></script>
    <script src="https://unpkg.com/feather-icons"></script>
    <link rel="stylesheet" href="new.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Review
### Daniel Anderson
### Week 9, Class 2

---




layout: true

  &lt;script&gt;
    feather.replace()
  &lt;/script&gt;
  
  &lt;div class="slides-footer"&gt;
  &lt;span&gt;
  
  &lt;a class = "footer-icon-link" href = "https://github.com/uo-datasci-specialization/c3-fp-2021/raw/main/static/slides/w9p2.pdf"&gt;
    &lt;i class = "footer-icon" data-feather="download"&gt;&lt;/i&gt;
  &lt;/a&gt;
  
  &lt;a class = "footer-icon-link" href = "https://fp-2021.netlify.app/slides/w9p2.html"&gt;
    &lt;i class = "footer-icon" data-feather="link"&gt;&lt;/i&gt;
  &lt;/a&gt;
  
  &lt;a class = "footer-icon-link" href = "https://fp-2021.netlify.app/"&gt;
    &lt;i class = "footer-icon" data-feather="globe"&gt;&lt;/i&gt;
  &lt;/a&gt;
  
  &lt;a class = "footer-icon-link" href = "https://github.com/uo-datasci-specialization/c3-fp-2021"&gt;
    &lt;i class = "footer-icon" data-feather="github"&gt;&lt;/i&gt;
  &lt;/a&gt;
  
  &lt;/span&gt;
  &lt;/div&gt;
  

---
# Agenda

* Review functions

* A shiny challenge
  + But first, a brief discussion on publishing shiny apps

---
class: inverse-blue middle
# Functions review

---
# Remember

* Everything is a function


--
The following are equivalent


```r
3 + 5
```

```
## [1] 8
```



```r
`+`(3, 5)
```

```
## [1] 8
```

---
# Using functions

* Most functions are bound to a name, e.g., `mean()`


--
* Anonymous functions are also common 

  + Apply the function in a loop, and it only ever exists in the loop
  

--
* You can also store functions in lists

  + Helpful if you want to apply lots of operations to a single vector

---
# Binding to a name

* Let's create a function that takes two arguments: (a) a data frame, and (b) the name of a discrete/categorical variable/column in the data frame.

* The function should return the count of each "level" in the categorical variable.

* For a small added challenge, have it optionally add the proportion

--
Example:



Example output with `palmerpenguins::penguins`.

.pull-left[

```
##     species count
## 1    Adelie   152
## 2 Chinstrap    68
## 3    Gentoo   124
```

]

.pull-right[

```
##     species count proportion
## 1    Adelie   152  0.4418605
## 2 Chinstrap    68  0.1976744
## 3    Gentoo   124  0.3604651
```
]


---
# You try first 

Test it out with the **palmerpenguins** dataset. Do you get the same results I did?

Note - the example I used included only base R functions. You can feel free to use **dplyr** or whatevs, just be careful with NSE.

You also don't have to return a data frame output - return it however you want

<div class="countdown" id="timer_60ad7aab" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">07</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---
# Where to start?

~~write a function~~

* Solve the problem for one example, generalize it to a function.


--
Use the **palmerpenguins** dataset *for* your example!


--

```r
library(palmerpenguins)
penguins
```

```
## # A tibble: 344 x 8
##    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex     year
##    &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt;  &lt;int&gt;
##  1 Adelie  Torgersen           39.1          18.7               181        3750 male    2007
##  2 Adelie  Torgersen           39.5          17.4               186        3800 female  2007
##  3 Adelie  Torgersen           40.3          18                 195        3250 female  2007
##  4 Adelie  Torgersen           NA            NA                  NA          NA &lt;NA&gt;    2007
##  5 Adelie  Torgersen           36.7          19.3               193        3450 female  2007
##  6 Adelie  Torgersen           39.3          20.6               190        3650 male    2007
##  7 Adelie  Torgersen           38.9          17.8               181        3625 female  2007
##  8 Adelie  Torgersen           39.2          19.6               195        4675 male    2007
##  9 Adelie  Torgersen           34.1          18.1               193        3475 &lt;NA&gt;    2007
## 10 Adelie  Torgersen           42            20.2               190        4250 &lt;NA&gt;    2007
## # … with 334 more rows
```

---
# How do you want to solve it?
Lots of ways, here's a base method

--
* First, split by species


```r
splt &lt;- split(penguins, penguins$species)
```

--
* Next, count how many rows (observations) in each split


```r
sapply(splt, nrow)
```

```
##    Adelie Chinstrap    Gentoo 
##       152        68       124
```

--
Could go on, but this is basically the output.

---
# Wrap in a function

* What will the arguments be?


--
The data frame and the column


```r
get_counts &lt;- function(df, column) {
  
}
```


--
What will the body be?

---
# Same as before
Just swap out the code for the arguments. Notice I'm indexing the columns differently. Why?

I'm also swapping out `sapply()` for `vapply()` to be a little more safe.


```r
get_counts &lt;- function(df, column) {
  splt &lt;- split(df, df[[column]])
  vapply(splt, nrow, FUN.VALUE = integer(1))
}
```

---
# Test it


```r
get_counts(penguins, "species")
```

```
##    Adelie Chinstrap    Gentoo 
##       152        68       124
```

```r
get_counts(penguins, "island")
```

```
##    Biscoe     Dream Torgersen 
##       168       124        52
```

---
# Extensions
Let's say we want a data frame as the output.

Can you modify what we have now to make that so?

<div class="countdown" id="timer_60ad7c18" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---
# Data frame


```r
get_counts &lt;- function(df, column) {
  splt &lt;- split(df, df[[column]])
  counts &lt;- vapply(splt, nrow, FUN.VALUE = integer(1))
  
  tibble::tibble(
    var_levels = names(counts), # could use names(splt)
    count = counts
  )
}
```

---
# Test it


```r
get_counts(penguins, "species")
```

```
## # A tibble: 3 x 2
##   var_levels count
##   &lt;chr&gt;      &lt;int&gt;
## 1 Adelie       152
## 2 Chinstrap     68
## 3 Gentoo       124
```

```r
get_counts(penguins, "island")
```

```
## # A tibble: 3 x 2
##   var_levels count
##   &lt;chr&gt;      &lt;int&gt;
## 1 Biscoe       168
## 2 Dream        124
## 3 Torgersen     52
```

---
# Column name

Can we make the output from the data frame have the same column that we fed it?

<div class="countdown" id="timer_60ad7be0" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">02</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

--


```r
get_counts &lt;- function(df, column) {
  splt &lt;- split(df, df[[column]])
  counts &lt;- vapply(splt, nrow, FUN.VALUE = integer(1))
  
  d &lt;- tibble::tibble(
    var_levels = names(counts), # could use names(splt)
    count = counts
  )
* names(d)[1] &lt;- column
  d
}
```

---
# Test it


```r
get_counts(penguins, "species")
```

```
## # A tibble: 3 x 2
##   species   count
##   &lt;chr&gt;     &lt;int&gt;
## 1 Adelie      152
## 2 Chinstrap    68
## 3 Gentoo      124
```

```r
get_counts(penguins, "island")
```

```
## # A tibble: 3 x 2
##   island    count
##   &lt;chr&gt;     &lt;int&gt;
## 1 Biscoe      168
## 2 Dream       124
## 3 Torgersen    52
```


---
# {dplyr} version

Can we replicate this function using dplyr?

We'll have to use non-standard evaluation


--

First, solve it on a use case


```r
penguins %&gt;% 
  count(species)
```

```
## # A tibble: 3 x 2
##   species       n
##   &lt;fct&gt;     &lt;int&gt;
## 1 Adelie      152
## 2 Chinstrap    68
## 3 Gentoo      124
```

---
# Function

Will this work?


```r
get_counts &lt;- function(df, column) {
  df %&gt;% 
    count(column)
}
```


--

```r
get_counts(penguins, species)
```

```
## Error: Must group by variables found in `.data`.
## * Column `column` is not found.
```

---
# Use NSE


```r
get_counts &lt;- function(df, column) {
  df %&gt;% 
    count({{column}})
}
```

--

```r
get_counts(penguins, species)
```

```
## # A tibble: 3 x 2
##   species       n
##   &lt;fct&gt;     &lt;int&gt;
## 1 Adelie      152
## 2 Chinstrap    68
## 3 Gentoo      124
```

```r
get_counts(penguins, island)
```

```
## # A tibble: 3 x 2
##   island        n
##   &lt;fct&gt;     &lt;int&gt;
## 1 Biscoe      168
## 2 Dream       124
## 3 Torgersen    52
```

---
# Pass the dots

Alternatively, you could just pass the dots

Bonus, this will now give you the counts for multiple columns


--

```r
get_counts &lt;- function(df, ...) {
  df %&gt;% 
    count(...)
}
```

---
# Test it


```r
get_counts(penguins, species)
```

```
## # A tibble: 3 x 2
##   species       n
##   &lt;fct&gt;     &lt;int&gt;
## 1 Adelie      152
## 2 Chinstrap    68
## 3 Gentoo      124
```

```r
get_counts(penguins, species, island)
```

```
## # A tibble: 5 x 3
##   species   island        n
##   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;
## 1 Adelie    Biscoe       44
## 2 Adelie    Dream        56
## 3 Adelie    Torgersen    52
## 4 Chinstrap Dream        68
## 5 Gentoo    Biscoe      124
```

---
# Conditions

* Let's add a condition that optionally reports the proportions in addition to the counts.


--
* What will be the first step?


--
* Add a new argument (and consider setting defaults for that argument)


--

```r
get_counts &lt;- function(df, column, return_proportions = FALSE) {
  df %&gt;% 
    count({{column}})
}
```

---
# Set conditional block
Create a block for operations to conduct **when the condition is TRUE**


```r
get_counts &lt;- function(df, column, return_proportions = FALSE) {
  counts &lt;- df %&gt;% 
    count({{column}})
  
  if (isTRUE(return_proportions)) {
    
  }
  counts
}
```

---
# Write condition
In the block, include the code that is only evaluated when the condition is `TRUE`.


```r
get_counts &lt;- function(df, column, return_proportions = FALSE) {
  counts &lt;- df %&gt;% 
    count({{column}})
  
  if (isTRUE(return_proportions)) {
    counts &lt;- counts %&gt;% 
      mutate(proportion = n / sum(n))
  }
  counts
}
```

---
# Test it


```r
get_counts(penguins, species)
```

```
## # A tibble: 3 x 2
##   species       n
##   &lt;fct&gt;     &lt;int&gt;
## 1 Adelie      152
## 2 Chinstrap    68
## 3 Gentoo      124
```

```r
get_counts(penguins, species, return_proportions = TRUE)
```

```
## # A tibble: 3 x 3
##   species       n proportion
##   &lt;fct&gt;     &lt;int&gt;      &lt;dbl&gt;
## 1 Adelie      152  0.4418605
## 2 Chinstrap    68  0.1976744
## 3 Gentoo      124  0.3604651
```

---
# Challenge
Now that we have a basic function, can you write a **new** function that *calls this function* to add the proportions and/or counts to a data frame?

Should return the original data frame, but with the counts/proportions added in as a new column.

<div class="countdown" id="timer_60ad7a40" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">04</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---
# One solution


```r
add_counts &lt;- function(data, column, add_proportions = FALSE) {
  counts &lt;- get_counts(data, {{column}}, add_proportions)
  left_join(data, counts)
}
```

---
# Test it out

I'm selecting variables after just so we can see the counts


```r
add_counts(penguins, species) %&gt;% 
  select(species, island, n)
```

```
## # A tibble: 344 x 3
##    species island        n
##    &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;
##  1 Adelie  Torgersen   152
##  2 Adelie  Torgersen   152
##  3 Adelie  Torgersen   152
##  4 Adelie  Torgersen   152
##  5 Adelie  Torgersen   152
##  6 Adelie  Torgersen   152
##  7 Adelie  Torgersen   152
##  8 Adelie  Torgersen   152
##  9 Adelie  Torgersen   152
## 10 Adelie  Torgersen   152
## # … with 334 more rows
```

---
# Test it again

This time let's add the proportions


```r
add_counts(penguins, species, add_proportions = TRUE) %&gt;% 
  select(species, island, n, proportion)
```

```
## # A tibble: 344 x 4
##    species island        n proportion
##    &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;      &lt;dbl&gt;
##  1 Adelie  Torgersen   152  0.4418605
##  2 Adelie  Torgersen   152  0.4418605
##  3 Adelie  Torgersen   152  0.4418605
##  4 Adelie  Torgersen   152  0.4418605
##  5 Adelie  Torgersen   152  0.4418605
##  6 Adelie  Torgersen   152  0.4418605
##  7 Adelie  Torgersen   152  0.4418605
##  8 Adelie  Torgersen   152  0.4418605
##  9 Adelie  Torgersen   152  0.4418605
## 10 Adelie  Torgersen   152  0.4418605
## # … with 334 more rows
```


---
# Embed checks

Can you embed a warning or error (your choice) if the column fed to the function is not discrete?

Note - this is more difficult with our **dplyr** version. Try using `dplyr::pull()`.

<div class="countdown" id="timer_60ad7a4d" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---


```r
get_counts &lt;- function(df, column, return_proportions = FALSE) {
  
  column_vec &lt;- dplyr::pull(df, {{column}})
  
  if(is.numeric(column_vec)) {
    stop("Numeric column passed to function. Counts must be computed on categorical data.")
  }
  
  counts &lt;- df %&gt;% 
    count({{column}})
  
  if (isTRUE(return_proportions)) {
    counts &lt;- counts %&gt;% 
      mutate(proportion = n / sum(n))
  }
  counts
}
```

---
# Test it out
Note we can test it with either the `get_counts()` or `add_counts()` functions


```r
get_counts(penguins, bill_length_mm)
```

```
## Error in get_counts(penguins, bill_length_mm): Numeric column passed to function. Counts must be computed on categorical data.
```

```r
add_counts(penguins, bill_length_mm)
```

```
## Error in get_counts(data, {: Numeric column passed to function. Counts must be computed on categorical data.
```

---
class: inverse-blue middle
# Shiny

---
# Publishing
* We never talked about publishing shiny apps

See [here](https://statsandr.com/blog/how-to-publish-shiny-app-example-with-shinyapps-io/) for a nice step-by-step walkthrough for publishing with https://www.shinyapps.io/

--
Basically:
* Register an account with https://www.shinyapps.io/
* Add a token to your account on shinyapps
* Back locally, set your account info with the token and secret via 


```r
rsconnect::setAccountInfo(
  name = "myaccount", # replace with your account name
  token = "mytokencopiedfromshinyappsio", # your token
  secret = "mysecretcopiedfromshinyappsio"
)
```

---
.center[
### Publish
]

.footnote[image from tutorial [here](https://statsandr.com/blog/how-to-publish-shiny-app-example-with-shinyapps-io/)]

![](https://statsandr.com/blog/2020-05-29-how-to-deploy-a-shiny-app-an-example-with-shinyapps-io_files/publish-shiny-app-online-shinyapps-io-4.png)

---
# Shiny app
* Create a shiny app or shiny dashboard with the `palmerpenguins` dataset

* Allow the x and y axis to be selected by the user
  + Only numeric variables should be available to be selected
  
* Allow the points to be colored by any categorical variable

  + For an added challenge, try to add in a "no color" option, which should be the default

Once you've gone this far, try to publish your app. If you're successful, continue with challenge on next slide

---
# Challenge continued

* Add a table to the app that reports descriptive data on the columns that are selected in the plot
  + e.g., `n()`, `mean()`, `sd()`
  
* Use tabs so the plot shows up in one tab, and the table shows up in a different tab

Now publish again to update it

---
class: inverse-green middle 
# Next time
## No Class Monday
## Package Development on Wednesday
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://platform.twitter.com/widgets.js"></script>
<script>var slideshow = remark.create({
"navigation": {
"scroll": false
},
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
